---
title: "Clodl:<br/>build, copy, and run"
shortTitle: Announcing clodl
author: Facundo Dominguez, Mathieu Boespflug
---

## Plan

The problem
 * Deploy dynamically linked executables or libraries.

One can choose to deliver statically linked executables
or docker containers, but ...

Motivation
 * JVM can link shared libraries or PIEs only.
   * Introduce briefly spark and how it launches distributed applications.
   * Explain that we want to produced self-contained jars.
 * Compilers usually link dynamically by default. So closures of
   libraries allow to trade the trouble of making full static
   programs ?

Explain clodl usage.

Explain the library wrapper/linking trick.

Explain briefly why Bazel in our case. But the solution can be
used in other settings.

---

Have you ever needed to execute in another computer a binary that you
have built, only to find that it doesn't work because it depends on
shared libraries which aren't installed? And even worse, you don't have
admin rights on the machine, so you cannot install the correct dependencies?

In this post we present [`clodl`][clodl], a tool to build self-contained
closures of dynamically linked executables and shared libraries.
The closure is a file that can be copied elsewhere and executed
or loaded as a library without depending on any libraries to be
installed.

[clodl]: https://github.com/tweag/clodl

## The problem

Copying executables is not the only way of deploying binaries.
For instance one could deliver a docker container with all the
dependencies, or one could build instead a fully static binary
executable. There are cases where these are not the ideal though.

One such case is feeding native code to the Java Virtual Machine
(JVM). The JVM can only load shared libraries. If we are to deploy
an hybrid application requiring both the JVM and native code, we
need to be sure that all the native code dependencies are shipped
or the JVM won't be able to load it.

A possibility is making something like a docker container
with the JVM and all the libraries. This can work as long as we
can control how the application is launched, but this was not
the case in our projects.

In our case, we have been using Spark, a system for running distributed
computations. Among other things, Spark interfaces with systems which
manage the resources in a cluster and orchestrates the creation of JVM
instances to run the distributed computations. Computations are
submitted to Spark as self-contained jar files containing the code to
execute. In this scenario, we must be able to encapsulate dependencies.

Another reason to consider using `clodl`, is that many compilers (GHC, for example)
don't build fully static executables by default. Depending on
the application, doing so might not be trivial.
The `clodl` approach offers a stop-gap solution and could be
definitive if the project does not need to go all the way to
fully static builds.

## What is a closure?

In essence, the closure of a shared library or executable is a file
containing this initial library or executable and its dependencies.
`clodl` creates a zip file, though any container format could do.

In addition, the closure must have some provisions to execute or
load the code contained within. For example, a Java application could
uncompress the closure and load the initial shared library. However,
this can cause problems, since
there is the danger that the dependencies would be searched at other
locations were incompatible libraries could be found.

Because of this, the closure has a wrapper library created
solely for the purpose of loading it. This wrapper library is
the result of linking dynamically the initial library and all
of its dependencies, and therefore all the libraries in the
closure are direct dependencies of it. Moreover, the
[runtime library path][runpath]
of this wrapper library instructs the dynamic loader to search
for dependencies at the same location where the wrapper is.

[runpath]: http://man7.org/linux/man-pages/man1/ld.1.html

If we want the closure to be executed rather than loaded, we
create a wrapper executable instead of a wrapper
library, which is linked in the same way.

## Creating closures

`clodl` is implemented with a mix of bash scripts and [Bazel][bazel]
rules. Bazel is a build system which is able to express dependencies
between source files in various languages (e.g. Haskell and Java).
While we have been using `clodl` with it, it is possible to
implement the same approach in other tools or even as a standalone
shell script.

[bazel]: https://bazel.build

In order to build a closure, one has to write rules in a BUILD file
which can be fed to Bazel. For instance

```
# bring into scope the library_closure rule
load(
    "@io_tweag_clodl//clodl:clodl.bzl",
    "library_closure",
)

# create a C library
cc_library(
    name = "lib-cc",
    srcs = ["lib.c"],
)

# create a shared library from the C library
cc_binary(
    name = "libhello-cc.so",
	# include a main function if you intend to make
	# the closure executable
    srcs = ["main.c"],
    deps = ["lib-cc"],
    linkshared = 1,
)

# create the closure of the shared library
library_closure(
    name = "clotest-cc",
    srcs = ["libhello-cc.so"],
)
```

The `library_closure` rule here produces a file `clotest-cc.zip`
containing all the shared libraries needed to load `libhello-cc.so`.
`clodl` finds the dependencies using whatever version of [`ldd`][ldd] is on the
PATH when Bazel runs the rules.

[ldd]: http://man7.org/linux/man-pages/man1/ldd.1.html

We can make the the closure executable by replacing the
`library_closure` rule with
```
binary_closure(
    name = "clotestbin-cc",
    src = "libhello-cc.so",
)
```
This will produce a file `clotestbin-cc.sh` that has the closure zip
file prepended with a bash script that invokes the main function in
`main.c`. The [`clodl` repository][clodl] has full examples.
At the time of this writing, we only have tested `clodl` in Linux.

## Summary

In this post we have presented `clodl`, a tool to build closures of
dynamically linked executables and shared libraries. These closures
are easy to copy and load or execute in other hosts.
We expect these capabilites to be useful to various projects.
You are welcome to get in touch if you would like to contribute or have
`clodl` features enhanced.
