---
title: "Clodl:<br/>build, copy, and run"
shortTitle: Announcing clodl
author: Facundo Dominguez, Mathieu Boespflug
---

Have you ever needed to execute in another computer a binary that you
have built, only to find that it doesn't work because it depends on
shared libraries which aren't installed? And even worse, you don't have
admin rights on the machine, so you cannot install the correct dependencies?

In this post we present [`clodl`][clodl], a tool to build self-contained
closures of dynamically linked executables and shared libraries.
The closure is a file that can be copied elsewhere and executed
or loaded as a library without depending on any pre-installed library.

[clodl]: https://github.com/tweag/clodl

## Deploying binaries

While copying executables is the simplest way to deploy a binary,
it depends strongly on a correctly configured computing environment.
Other options, such as delivering a Docker container with all the
dependencies, or building instead a fully static binary executable
alleviate this problem. However, there are cases where these methods are
not appropriate.

One such case is feeding native code to the Java Virtual Machine
(JVM). The JVM can only load shared libraries. If we are to deploy
an hybrid application requiring both the JVM and native code, we
need to be sure that all the native code dependencies are shipped
or the JVM won't be able to load it.

A possibility is making something like a Docker container
with the JVM and all the libraries. This can work as long as we
have control over how the application is launched, which was not
the case in one of our projects.

In this project, we use Spark, a system for running distributed
computations. Among other things, Spark interfaces with systems which
manage resources in a cluster and orchestrates the creation of JVM
instances to run distributed computations. Computations are
submitted to Spark as self-contained JAR files containing the code to
execute. In this scenario, we must be able to encapsulate dependencies.

Another situation where `clodl` can be useful is when one needs
static builds, but is using a compiler (such as GHC, for example)
that don't build fully static executables by default. Depending on
the application, doing so might not be trivial.
The `clodl` approach offers a stop-gap solution and could be
definitive if the project does not need to go all the way to
fully static builds.

## What is a closure?

In essence, the closure of a shared library or executable is a file
containing this initial library or executable and its dependencies.
In the case of `clodl` this takes the form of a zip archive, though any container format could be used.

In addition, the closure must have some provisions to execute or
load the code contained within. For example, a Java application could
uncompress the closure and load the initial shared library. However,
this can cause problems, since
there is the danger that the dependencies would be searched at other
locations were incompatible libraries could be found.

Because of this, the closure has a wrapper library created
solely for the purpose of loading it. This wrapper library is
the result of linking dynamically the initial library and all
of its dependencies, and therefore all the libraries in the
closure are direct dependencies of it. Moreover, the
[runtime library path][runpath]
of this wrapper library instructs the dynamic loader to search
for dependencies at the same location where the wrapper is.

[runpath]: http://man7.org/linux/man-pages/man1/ld.1.html

If we want the closure to be executed rather than loaded, we
create a wrapper executable instead of a wrapper
library, which is linked in the same way.

## Creating closures

`clodl` is implemented with a mix of bash scripts and [Bazel][bazel]
rules. Bazel is a build system which is able to express dependencies
between source files in various languages (e.g. Haskell and Java).
While we have been using `clodl` with it, it is possible to
implement the same approach in other tools or even as a standalone
shell script.

[bazel]: https://bazel.build

In order to build a closure, one has to write rules in a BUILD file
which can be fed to Bazel. For instance

```
# bring into scope the library_closure rule
load(
    "@io_tweag_clodl//clodl:clodl.bzl",
    "library_closure",
)

# create a C library
cc_library(
    name = "lib-cc",
    srcs = ["lib.c"],
)

# create a shared library from the C library
cc_binary(
    name = "libhello-cc.so",
	# include a main function if you intend to make
	# the closure executable
    srcs = ["main.c"],
    deps = ["lib-cc"],
    linkshared = 1,
)

# create the closure of the shared library
library_closure(
    name = "clotest-cc",
    srcs = ["libhello-cc.so"],
)
```

The `library_closure` rule here produces a file `clotest-cc.zip`
containing all the shared libraries needed to load `libhello-cc.so`.
`clodl` finds the dependencies using whatever version of [`ldd`][ldd] is on the
PATH when Bazel runs the rules.

[ldd]: http://man7.org/linux/man-pages/man1/ldd.1.html

We can make the the closure executable by replacing the
`library_closure` rule with
```
binary_closure(
    name = "clotestbin-cc",
    src = "libhello-cc.so",
)
```
This will produce a file `clotestbin-cc.sh` that has the closure zip
file prepended with a bash script that invokes the main function in
`main.c`. The [`clodl` repository][clodl] has full examples.
At the time of this writing, we only have tested `clodl` in Linux.

## Tools for deployment

`clodl` is not the first tool on Linux to deploy binaries. There
are [Flatpack][flatpack] and [Snap][snap], for instance. These are build
tools that start from the source code to build cross-linux packages.

There is also [nix-bundle][nix-bundle], which requires the application
to be packaged with [nix][nix] in order to provide a binary which
bundles all of its dependencies.

All of these tools require especifying the dependencies, the source
code and any build settings. `clodl`, in contrast, starts from the
executable binary or shared library, written in any language, built by
any compiler. It may be regarded as similar to a commercial tool called
[ermine][ermine]. This tool, however, does not provide insights on the
structure of the produced binary. `clodl`, on the contrary, produces a
zip file that can be uncompressed by applications. We can't depart with
this ability if we are to load the contents in the JVM.

[flatpack]: https://flatpak.org
[snap]: https://snapcraft.io
[ermine]: http://www.magicermine.com/sesl.html
[nix]: https://nixos.org/nix
[nix-bundle]: https://github.com/matthewbauer/nix-bundle

## Summary

In this post we have presented `clodl`, a tool to build closures of
dynamically linked executables and shared libraries. These closures
are easy to copy and load or execute in other hosts.
We expect these capabilites to be useful to various projects.
You are welcome to get in touch if you would like to contribute or have
`clodl` features enhanced.
