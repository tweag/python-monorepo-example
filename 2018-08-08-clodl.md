---
title: "Clodl:<br/>build, copy, and run"
shortTitle: Announcing clodl
author: Facundo Dominguez, Mathieu Boespflug
---

## Plan

The problem
 * Deploy dynamically linked executables or libraries.

One can choose to deliver statically linked executables
or docker containers, but ...

Motivation
 * JVM can link shared libraries or PIEs only.
   * Introduce briefly spark and how it launches distributed applications.
   * Explain that we want to produced self-contained jars.
 * Compilers usually link dynamically by default. So closures of
   libraries allow to trade the trouble of making full static
   programs ?

Explain clodl usage.

Explain the library wrapper/linking trick.

Explain briefly why Bazel in our case. But the solution can be
used in other settings.

---

Have you ever needed to execute in another computer a binary that you
have built, only to find that it doesn't work because it depends on
shared libraries which aren't installed?

In this post we present [clodl][clodl], a tool to build self-contained
closures of dynamically linked executables and shared libraries.
The closure is a file that can be copied elsewhere and executed
or loaded as a library without depending on any libraries to be
installed.

[clodl]: https://github.com/tweag/clodl

## The problem

Deployment of binaries can be certainly achieved by other means.
For instance one could deliver a docker container with all the
dependencies, or one could build instead a fully static binary
executable. There are cases where these are not the ideal though.

One such case is feeding native code to the Java Virtual Machine
(JVM). The JVM can only load shared libraries. If we are to deploy
an hybrid application requiring both the JVM and native code, we
need to be sure that all the native code dependencies are shipped
or the JVM won't be able to load it.

We could still consider making something like a docker container
with the JVM and all the libraries. This can work as long as we
can control how the application is launched, but this was neither
the case in our projects.

We have been using Spark, a system for running distributed
computations. Among other things, Spark interfaces with systems which
manage the resources in a cluster and orchestrates the creation of JVM
instances to run the distributed computations. Computations are
submitted to Spark as self-contained jar files containing the code to
execute. In this scenario, we were forced to use something like clodl.

Another reason to consider using clodl, is that many compilers
don't build fully static executables by default. Depending on
the application this might be achieved with variable effort.
The clodl approach offers a stop-gap solution and could be
definitive if the project does not need to go all the way to
fully static builds.

## What is a closure?

In essence, a closure of a shared library or executable is a file
containing this initial library or executable and its dependencies.
clodl creates a zip file, though any container format could do.

In addition, the closure must have some provisions to execute or
load the code contained within. A Java application could
uncompress the closure and load the initial shared library, but
there is the danger that the dependencies would be searched at other
locations were incompatible libraries could be found.

Because of this, the closure has a wrapper library created
solely for the purpose of loading it. This wrapper library is
the result of linking dynamically the initial library and all
of its dependencies, and therefore all the libraries in the
closure are direct dependencies of it. Moreover, the
[runtime library path][runpath]
of this wrapper library instructs the dynamic loader to search
for dependencies at the same location where the wrapper is.

[runpath]: http://man7.org/linux/man-pages/man1/ld.1.html

If we want the closure to be executed rather than loaded, we
arrange to create a wrapper executable instead of a wrapper
library, which is linked in the same way.

## Creating closures

clodl is implemented with a mix of bash scripts and [Bazel][bazel]
rules. Bazel is a build system which is able to express dependencies
between source files in various languages (e.g. Haskell and Java),
and we have been using clodl with it. But it is possible to
implement the same approach in other tools or even as a standalone
shell script.

[bazel]: https://bazel.build

In order to build closure one has to write rules in a BUILD file which
can be fed to Bazel. For instance

```
load(
    "@io_tweag_clodl//clodl:clodl.bzl",
    "library_closure",
)

cc_library(
    name = "lib-cc",
    srcs = ["lib.c"],
    testonly = True,
)

cc_binary(
    name = "libhello-cc.so",
    srcs = ["main.c"],
    deps = ["lib-cc"],
    linkshared = 1,
)

library_closure(
    name = "clotest-cc",
    srcs = ["libhello-cc.so"],
)
```

The `library_closure` rule here produces a file `clotest-cc.zip`
containing all the shared libraries needed to load `libhello-cc.so`.
clodl finds the dependencies using whatever version of [ldd][ldd] is on the
PATH when Bazel runs the rules. At the time of this writing, we only
have tested clodl in linux.

[ldd]: http://man7.org/linux/man-pages/man1/ldd.1.html

We can make the the closure executable by replacing the
`library_closure` rule with
```
binary_closure(
    name = "clotestbin-cc",
    src = "libhello-cc.so",
)
```
This will produce a file `clotestbin-cc.sh` that has the closure zip
file prepended with a bash script that invokes the main function in
`main.c`.

## Summary

In this post we have presented clodl, a tool to build closures of
dynamically linked executables and shared libraries. These closures
are easy to copy and load or execute in other hosts. We hope that this
ability is useful to various projects. You are welcome to get in touch
if you would like to contribute or have clodl features enhanced.
