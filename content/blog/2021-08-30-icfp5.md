---
title: "Daily ICFP: Day 5"
author: Noon van der Silk, Arnaud Spiwack, Richard Eisenberg
tags: [icfp, haskell]
description: "Notes from the sixth day of ICFP"
---

# Daily ICFP

Several Tweagers all agreed to gather notes here about our
[ICFP](https://icfp21.sigplan.org/) (International Conference on Functional
Programming) experiences. We plan to publish these notes every evening.

## Day 5 - Friday

These notes follow Noon and Richard through their day at ICFP,
roughly in order. (The talks are not publicly posted at the time
of publication of this post, but we expect they will be over the
coming weeks.)

_Arnaud_ -- [Parafuzz: Coverage-guided Property Fuzzing for Multicore OCaml programs](https://icfp21.sigplan.org/details/ocaml-2021-papers/9/Parafuzz-Coverage-guided-Property-Fuzzing-for-Multicore-OCaml-programs): this is in the context of multicore Ocaml (multicore Ocaml has algebraic effects). The authors use algebraic effects to abstract over concurrency primitives, so that they can test concurrency property with the AFL fuzzer (AFL tries generate random inputs, here random schedules, while trying very hard to trigger code paths that were not covered by previous runs).

_Arnaud_ -- [Wibbily Wobbly Timey Camly](https://icfp21.sigplan.org/details/ocaml-2021-papers/13/Wibbily-Wobbly-Timey-Camly): an Ocaml library to deal with time, timezones, time intervals, etcâ€¦ The talk focussed a lot on finding out whether a particular date belong to a set of dates. These sets are built by assembling constraints. It's an unusual, but very convincing design.

_Noon_ -- FARM starts today! I'm so excited; I've wanted to attend FARM
for _years_, and this is my first opportunity!

_Noon_ -- [mimium: a self-extensible programming language for sound and music](https://icfp21.sigplan.org/details/farm-2021-papers/2/mimium-a-self-extensible-programming-language-for-sound-and-music)

- Nice language that has scheduling and state.
- Has a focus on composition over live-coding (c.f. extempore, say.)

_Noon_ -- Unfortunately, the next speaker wasn't able to make it, so there was no talk.

_Noon_ -- Bit disappointed that FARM and Haskell Symposium are on at the same time, I've
ended up attending Haskell, and I'll hope to watch FARM at a later point.

[Practical Normalization by Evaluation for EDSLs](https://icfp21.sigplan.org/details/haskellsymp-2021/5/Practical-Normalization-by-Evaluation-for-EDSLs), by Nachiappan Villiappan, Alejandro Russo, and Sam Lindley

_Noon_

- Prefer shallow over deep embedding to piggy-back features from the host language.
- Downside is we've lost syntax for the operations.
- Maybe one way is to interconvert between expression representation and host (?) representation
- Doesn't always work; sometimes there's no unique choice.

_Richard_

I had heard the term "normalization by evaluation" a number of times in the
literature, but I never really understood it until watching this talk: the
idea is to take a bit of syntax, interpret it into a semantic domain (that is,
reinterpret it as an expression in the host language) and then inject the
result back into the encoding of the syntax of the object language. The only
problem is, now that I've described it thusly, it feels vacuous once again:
what is the difference between "normalization by evaluation" and just
evaluating terms in your object language? The term keeps cropping up, but I
don't really get it.

Let me think a bit more about what the words mean: normalization is the
process of finding a normal form, where a normal form is (generally) a
distinguished member of an equivalence class, useful for checking membership
in the equivalence class. That is, if we want to identify all semantically
equal expressions, we want to notice that `1 + 1` and `2` are semantically
equal; thus, they are in the same equivalence class. A good way to notice this
is to choose one distinguished member of each equivalence class: this is the
normal form. For `1 + 1` and `2`, `2` will be this normal form. Evaluation is
a separate process by which we take an expression and simplify it according to
well-established rules of evaluation.

Putting this together, we might surmise that "normalization by evaluation" is
an approach for checking semantic equality of expressions, using this recipe:

- To determine whether `e1` and `e2` are equal:
  1. Evaluate `e1` to yield value `v1`.
  2. Evaluate `e2` to yield value `v2`.
  3. Declare that `e1` is semantically equal to `e2` iff `v1` is syntactically equal to `v2`.

This process does not really care what `v1` and `v2` are -- just whether
they're syntactically equal. So maybe that really is the essence of
normalization by evaluation. And I've probably struggled to understand this
because this process seems "obvious" to me, and so I cannot really imagine
another way of checking semantic equality of expressions.

In the end, I'm not sure whether this definition of
normalization-by-evaluation is correct, and I'm afraid I got stuck on this
during the talk and did not extract other useful bits.

_Noon_ -- [Safe Mutation with Algebraic Effects](https://icfp21.sigplan.org/details/haskellsymp-2021/10/Safe-Mutation-with-Algebraic-Effects)

- Concurrency is frustrating; we don't want non-determinism!
- Maybe algebraic effects can help?
- Idea: Annotate the resources and modify these to control what can be done.
- All works

_Richard_ -- [Seeking Stability by being Lazy and Shallow: Lazy and shallow instantiation is user friendly](https://icfp21.sigplan.org/details/haskellsymp-2021/7/Seeking-Stability-by-being-Lazy-and-Shallow-Lazy-and-shallow-instantiation-is-user-f), by Gert-Jan Bottu and Richard A. Eisenberg.

I will not comment further on this talk other than to include this shameless
plug, and to publicly state how much I enjoyed working with former Tweag
intern Gert-Jan on developing this paper. I do hope to submit a proposal
requesting lazy instantiation in future versions of GHC.

_Noon_ -- I had wanted to watch the [Linear Haskell, Today and Tomorrow](https://icfp21.sigplan.org/details/haskellsymp-2021/13/Linear-Haskell-Today-and-Tomorrow)
talk, but it was scheduled alongside ShutdownPL (_and_ FARM); I really want to support
ICFPs efforts for more DEI (diversity, equity, and inclusion) content so I feel compelled to attend ShutdownPL; I'll have
to catch the other talks at a later time.

_Richard_ -- [Linear Haskell, Today and Tomorrow](https://icfp21.sigplan.org/details/haskellsymp-2021/13/Linear-Haskell-Today-and-Tomorrow), keynote by former Tweager Jean-Philippe Bernardy

This is a fine keynote describing the state of linear types in Haskell today
and sketching out how we can extract more from them in the future. In
particular, it describes the long-term plan for supporting pure
mutable-in-place structures, as long as we can verify statically (via linear
types) that there are never two live copies of the structures.

_Noon_ -- [ShutdownPL](https://icfp21.sigplan.org/details/icfp-2021-social-events/12/ShutdownPL)

- The one thing I take away from this is the idea that there is not simply a "pipeline" problem; there's also a problem on _the other end of the pipe_. I.e. think about how to remove problematic people from the community, instead of just getting new people in. I.e. think about why people _leave_. I think this is a powerful concept.
- Another idea that was brought up that I really liked is the idea of surveying your community to find out who is leaving and why. I think there's a lot to do here, and it could be very impactful.

_Noon_ -- [Deadlock-Free Session Types in Linear Haskell](https://icfp21.sigplan.org/details/haskellsymp-2021/1/Deadlock-Free-Session-Types-in-Linear-Haskell)

- Really enjoying the presentations by Wen; she has a very engaging style.
- First time I've heard about Session types, but I think I got a good feeling.
- Overall I really enjoyed it!

_Noon_ -- [Evaluating Linear Functions to Symmetric Monoidal Categories](https://icfp21.sigplan.org/details/haskellsymp-2021/2/Evaluating-Linear-Functions-to-Symmetric-Monoidal-Categories)

- Box and wire diagrams.
- Symmetric Monoidal Categories (SMCs).
- Issue with Arrows is that they don't represent these box-and-write diagrams very well; and in particular fail at the parallelisation.
- Idea is to use arrows to implement the an SMC, so that they are easier to work with.
- Perhaps has applications to quantum computing!
- So of course I'm interested, and will try and do a bit more reading.
